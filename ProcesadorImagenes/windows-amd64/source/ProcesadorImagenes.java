/* autogenerated by Processing revision 1293 on 2025-01-29 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import controlP5.*;
import java.util.ArrayList;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class ProcesadorImagenes extends PApplet {



ControlP5 p5;
UIManager ui;
ImageProcessor img;

public void setup()
{
  /* size commented out by preprocessor */;
  
  p5 = new ControlP5(this);
  
  img = new ImageProcessor();
  ui = new UIManager(p5);
  
  setupFilters();
}

public void draw()
{
  background(0);
  img.DrawImages();
}


//Aplicar el procesado de la imagen
public void ApplyProcessing()
{
  //Aplicar el filtro actualmente seleccionado
  img.Apply(ui.GetCurrentSelectedFilter());
}

public void setupFilters()
{
  
  //Inicializar filtros
  img.addFilter(new GrayScaleFilter());
  img.addFilter(new RedFilter());
  img.addFilter(new GreenFilter());
  img.addFilter(new BlueFilter());
  img.addFilter(new BinarizationFilter());
  img.addFilter(new BrightnessFilter());
  img.addFilter(new RGBLevelsFilter());
  img.addFilter(new InvertFilter());
  
  //Agregarlos a la ui
  ui.AddFilterList(img.GetFilterList());
  
  //Inicializa los controles de UI de los filtros
  for(BaseFilter f : img.GetFilterList())
  {
    f.StartControls(p5);
  }
  
  //Mostrar controles del filtro por defecto
  img.GetFilterList().get(0).ShowControls();
}

//Actualiza la UI para mostrar los controles del filtro seleccionado actualmente
public void updateUI()
{
  img.SwitchUI(ui.GetCurrentSelectedFilter());
}


//// I/O DE IMAGENES
  
//Cargar imagen
public void LoadImage()
{
  selectInput("Elige una imagen a procesar", "validateInput");
}

//Validar la seleccion de archivo a cargar
public void validateInput(File input)
{
  if(input == null)
  {
    println("No se seleccionó ninguna imagen");
    return;
  }
  img.LoadImage(input.getAbsolutePath());
}

//Guardar imagen
public void SaveProcessed()
{
  selectOutput("Elige donde guardar la imagen procesada", "validateOutput");
}

//Validar destino de guardado
public void validateOutput(File output)
{
  if(output == null)
  {
    println("No se eligio ningun archivo de salida");
    return;
  }
  
  String path = output.getAbsolutePath();
  
  //Si el usuario no especificó un formato de imagen (PGN o JPG), asignar JPG por defecto
  if(!path.toLowerCase().endsWith(".png") && !path.toLowerCase().endsWith(".jpg"));
  {
    path += ".jpg";
  }
  img.SaveProcessed(path);
}
public abstract class BaseFilter
{
  protected String name;
  
  protected int imageWidth;
  protected int imageHeight;
  
  protected Group controls;
  
  public BaseFilter(){}
  
  public BaseFilter(String name)
  {
    this.name = name;
  }
  
  /**
  * Funcion que aplica el filtro a la imagen de entrada, guardando el resultado en la imagen de salida
  *
  * @param input Imagen a procesar
  * @param output Imagen de salida procesada
  */
  public void ProcessImage(PImage input, PImage output)
  {
    input.loadPixels();
    output.loadPixels();
    
    int location = 0;
    imageWidth = input.width;
    imageHeight = input.height;
    
    for(int y = 0; y < imageHeight; y++)
    {
      for(int x = 0; x < imageWidth; x++)
      {
        location = pixelLocation(x, y);
        output.pixels[location] = pixelProcessing(x, y, location, input.pixels);
      }
    }
    
    output.updatePixels();
  }
  
  /**
  *  Inicializa grupos para que los filtros puedan crear sus propios controles de UI
  *  @param cp5 ControlP5 de la ui
  */
  public void StartControls(ControlP5 cp5)
  {
    controls = cp5.addGroup(name);
    setupControls(cp5);
    controls.hide();
  }
  
  //Funcion para que cada filtro pueda crear sus propios controles
  protected abstract void setupControls(ControlP5 cp5);
  
  //Muestra los controles de este filtro
  public void ShowControls()
  {
    controls.show();
  }
  
  //Oculta los controles del filtro
  public void HideControls()
  {
    controls.hide();
  }
  /**
  * Funcion por pixel para el procesamiento de la imagen
  *  @param x coordenada x del pixel en la imagen
  *  @param y coordenada y del pixel en la imagen
  *  @param location indice del pixel en el arreglo de pixeles
  *  @param pix arreglo que contiene la informacion de los pixeles de las imagenes
  *
  *  @return color resultante del procesamiento
  */
  protected abstract int pixelProcessing(int x, int y, int location, int[] pix);
  
  /**
  *  Calcula el indice de un pixel en el arreglo de pixeles dado su cordenada en la imagen
  *  @param x coordenada x del pixel en la imagen
  *  @param y coordenada y del pixel en la imagen
  *  @return indice correspondiente del pixel en el arreglo
  */
  private int pixelLocation(int x, int y)
  {
    return x + y * imageWidth;
  }
  
  public String GetName()
  {
    return name;
  }
  
}
/**
* Filtro de canal rojo
*/
public class RedFilter extends BaseFilter
{
  public RedFilter()
  {
    super("Escala de Rojos");
  }
  public RedFilter(String n)
  {
    super(n);
  }
  protected int pixelProcessing(int x, int y, int l, int[] input)
  {
    return color(red(input[l]), 0, 0);
  }
  protected void setupControls(ControlP5 cp5)
  {
  }
}

/**
* Filtro de canal verde
*/

public class GreenFilter extends BaseFilter
{
  public GreenFilter()
  {
    super("Escala de Verdes");
  }
  public GreenFilter(String n)
  {
    super(n);
  }
  
  protected int pixelProcessing(int x, int y, int l, int[] input)
  {
    return color(0, green(input[l]), 0);
  }
  
  protected void setupControls(ControlP5 cp5)
  {
  }
}

/**
* Filtro de canal Azul
*/

public class BlueFilter extends BaseFilter
{
  public BlueFilter()
  {
    super("Escala de Azules");
  }
  
  public BlueFilter(String n)
  {
    super(n);
  }
  protected int pixelProcessing(int x, int y, int l, int[] input)
  {
    return color(0, 0, blue(input[l]));
  }
  
  protected void setupControls(ControlP5 cp5)
  {
  }
}
/**
*  Controlador de slider extendido.
*  Contiene botones de suma y resta en ambos extremos
*  para facilitar la eleccion de un valor
*/


public class CustomSliderController
{
  Slider slider;
  Button plus;
  Button minus;
  
  /*
  *   Constructor
  *  @param controls grupo de controles al que pertenece
  *  @param p5 control de ui del programa
  *  @param name nombre del control, para evitar nombres repetidos
  *  @param y traslacion en y respecto al origen del grupo
  */
  public CustomSliderController(Group controls, ControlP5 p5, String name, float posY)
  {
    //Slider
    slider = new Slider(p5, "Rango" + name);
    slider.setLabel("");
    slider.setSize(160, 15);
    slider.setPosition(20, posY);
    
    slider.setRange(0,255);
    slider.setValue(128);
    slider.setSliderMode(0);
    
    slider.setScrollSensitivity(0);
    
    slider.onRelease(event -> updateSlider());
    slider.onReleaseOutside(event -> updateSlider());
    
    slider.setGroup(controls);
    
    //Boton +
    plus = new Button(p5, "Addition" + name);
    plus.setLabel("+");
    plus.setSize(15,15);
    plus.setPosition(190,posY);
    plus.setGroup(controls);
    plus.onRelease(event -> addValue());
    
    //boton -
    minus = new Button(p5, "Minus" + name);
    minus.setLabel("-");
    minus.setSize(15,15);
    minus.setPosition(0,posY);
    minus.setGroup(controls);
    minus.onRelease(event -> minusValue());
  }
  
  /*
  * Obtiene el valor del slider
  *  @return valor del slider
  */
  public float GetValue()
  {
    return slider.getValue();
  }
  
  /*
  *  Cambia el valor del slider
  *  @param val valor nuevo
  */
  public void SetValue(float val)
  {
    slider.setValue(val);
  }
  
  /*
  *  Establece el rango de valores del slider
  *  @param min valor minimo
  *  @param max valor maximo
  */
  public void SetRange(float min, float max)
  {
    slider.setRange(min,max);
  }
  
  public void SetColor(int rgb)
  {
    slider.setColorBackground(rgb);
    plus.setColorBackground(rgb);
    minus.setColorBackground(rgb);
    
  }
  
  //Actualiza el slider para tener un valor entero
  private void updateSlider()
  {
    slider.setValue((float)Math.floor(slider.getValue()));
  }
  
  //suma 1 al valor del slider
  private void addValue()
  {
    slider.setValue(slider.getValue()+1);
    updateSlider();
  }
  
  //resta 1 al valor del slider
  private void minusValue()
  {
    slider.setValue(slider.getValue()-1);
    updateSlider();
  }
}
/*
*  Filtro monocromatico
*/  

public class GrayScaleFilter extends BaseFilter
{
  public GrayScaleFilter()
  {
    super("Escala de Grises");
  }
  
  public GrayScaleFilter(String n)
  {
    super(n);
  }
  
  protected int pixelProcessing(int x, int y, int l, int[] input)
  {
    float r = red(input[l]);
    float g = green(input[l]);
    float b = blue(input[l]);
    
    float k = r * 0.2126f + g * 0.7152f + b * 0.0722f;
    return color(k,k,k);
  }
  
  protected void setupControls(ControlP5 cp5)
  {
  }
}
/**
*  Filtro binarizacion/alto contraste. Cambia el valor de un pixel a negro o blanco
*  dependiendo de un valor umbral (por defecto 128)
*
*/

public class BinarizationFilter extends BaseFilter
{
  CustomSliderController slider;
  
  public BinarizationFilter()
  {
    super("Alto Contraste");
  }
  
  public BinarizationFilter(String n)
  {
    super(n);
  }
  
  protected int pixelProcessing(int x, int y, int l, int[] input)
  {
    float r = red(input[l]);
    float g = green(input[l]);
    float b = blue(input[l]);
    
    float k = r * 0.2126f + g * 0.7152f + b * 0.0722f;
    k = k > slider.GetValue() ? 255 : 0;
    return color(k,k,k);
  }
  
  protected void setupControls(ControlP5 p5)
  {
    controls.setLabel("Controles de Binarizacion");
    controls.setSize(200, 400);
    controls.setPosition(width - 250, 30);
    
    slider = new CustomSliderController(controls, p5, "Binarization", 10);
  }
  
}
/**
*  Clase encargada de procesar la imagen
*
*/



public class ImageProcessor
{
  PImage base;        //Imagen a procesar
  PImage processed;   //Imagen procesada
  
  ArrayList<BaseFilter> filtros;
  
  public ImageProcessor()
  {
    base = loadImage("../sample.jpg");
    processed = loadImage("../sample.jpg");
    //Lista de filtros
    filtros = new ArrayList<BaseFilter>();
  }
  
  /**
  *  Dibuja la imagen y el resultado del procesamiento
  */
  public void DrawImages()
  {
    float desiredWidth = ((width - 300) * 0.5f) - 20 ;
    float ratio = desiredWidth / base.width;
    if(base != null)
    {
      image(base, 10, 60, desiredWidth, base.height * ratio);
    }
    if(processed != null)
    {
      image(processed, desiredWidth + 20, 60, desiredWidth, base.height * ratio);
    }
  }
  /**
  * Aplica un filtro actual a la imagen
  * @param seleccion Numero de filtro a aplicar
  */
  public void Apply(int seleccion)
  {
    if(filtros.size() < 0)
    {
      return;
    }
    if(seleccion < 0 || seleccion >= filtros.size())
    {
      return;
    }
    filtros.get(seleccion).ProcessImage(base, processed);
  }
  
  /**
  *  Cambia la UI para mostrar los controles del filtro actualmente seleccionado
  *
  *  @param i indice del filtro cuyos controles se van a mostrar
  */
  public void SwitchUI(int i)
  {
    for(BaseFilter f : filtros)
    {
      f.HideControls();
    }
    filtros.get(i).ShowControls();
  }
  
  /**
  *  Agrega un filtro a la lista de filtros disponibles
  *  
  *  @param filtro filtro a agregar
  */
  public void addFilter(BaseFilter filtro)
  {
    if(filtros == null)
    {
      filtros = new ArrayList<BaseFilter>();
    }
    filtros.add(filtro);
  }
  
  /**
  * Regresa la lista de filtros
  * @retun lista de filtros
  */
  public ArrayList<BaseFilter> GetFilterList()
  {
    return filtros;
  }
  
  ///// GETTERS
  
  public PImage GetBaseImage()
  {
    return base;
  }
  
  public PImage GetProcessedImage()
  {
    return processed;
  }
   
  /**
  *  Carga una imagen para ser procesada
  *
  *  @param path ubicacion absoluta del archivo
  */
  public void LoadImage(String path)
  {
    base = loadImage(path);
    processed = loadImage(path);
  }
  
   /*
   *  Guarda la imagen procesada en el sistema
   *  
   *  @param path ubicacion absoluta del destino del archivo
   */
  public void SaveProcessed(String path)
  {
    processed.save(path);
  }
}
/**
*
*  Filtro de brillo
*  Suma/resta un valor a los canales de la imagen
*
*/

public class BrightnessFilter extends BaseFilter
{
  CustomSliderController slider;
  
  public BrightnessFilter()
  {
    super("Brillo");
  }
  
  public BrightnessFilter(String n)
  {
    super(n);
  }
  
  protected int pixelProcessing(int x, int y, int l, int[] input)
  {
    float r = red(input[l]);
    float g = green(input[l]);
    float b = blue(input[l]);
    
    r += slider.GetValue();
    r = r < 0 ? 0 : r > 255? 255 : r;
    
    g += slider.GetValue();
    g = g < 0 ? 0 : g > 255? 255 : g;
    
    b += slider.GetValue();
    b = b < 0 ? 0 : b > 255? 255 : b;
    return color(r,g,b);
  }
  
  protected void setupControls(ControlP5 p5)
  {
    controls.setLabel("Controles de Brillo");
    controls.setSize(200, 400);
    controls.setPosition(width - 250, 30);
    
    slider = new CustomSliderController(controls, p5, "Brightness", 10);
    slider.SetRange(-255, 255);
    slider.SetValue(0);
  }
}

/**
*
*  Filtro de niveñes
*  Similar al filtro de brillo, pero el calculo se hace por canal
*
*/

public class RGBLevelsFilter extends BaseFilter
{
  CustomSliderController rojo;
  CustomSliderController verde;
  CustomSliderController azul;
  
  public RGBLevelsFilter()
  {
    super("Niveles RGB");
  }
  
  public RGBLevelsFilter(String n)
  {
    super(n);
  }
  
  protected int pixelProcessing(int x, int y, int l, int[] input)
  {
    float r = red(input[l]);
    float g = green(input[l]);
    float b = blue(input[l]);
    
    r += rojo.GetValue();
    r = r < 0 ? 0 : r > 255? 255 : r;
    
    g += verde.GetValue();
    g = g < 0 ? 0 : g > 255? 255 : g;
    
    b += azul.GetValue();
    b = b < 0 ? 0 : b > 255? 255 : b;
    return color(r,g,b);
  }
  
  protected void setupControls(ControlP5 p5)
  {
    controls.setLabel("Controles de Niveles");
    controls.setSize(200, 400);
    controls.setPosition(width - 250, 30);
    
    rojo = new CustomSliderController(controls, p5, "RLevel", 10);
    rojo.SetRange(-255, 255);
    rojo.SetValue(0);
    rojo.SetColor(color(128,0,0));
    
    verde = new CustomSliderController(controls, p5, "GLevel", 30);
    verde.SetRange(-255, 255);
    verde.SetValue(0);
    verde.SetColor(color(0,128,0));
    
    azul = new CustomSliderController(controls, p5, "BLevel", 50);
    azul.SetRange(-255, 255);
    azul.SetValue(0);
    azul.SetColor(color(0,0,218));
  }
}

/**
*
*  Filtro que invierte el valor de los canales
*
*/
public class InvertFilter extends BaseFilter
{
  public InvertFilter()
  {
    super("Invertir");
  }
  
  public InvertFilter(String n)
  {
    super(n);
  }
  
  protected int pixelProcessing(int x, int y, int l, int[] input)
  {
    float r = red(input[l]);
    float g = green(input[l]);
    float b = blue(input[l]);
    
    return color(255 - r, 255 - g, 255 - b);
  }
  
  protected void setupControls(ControlP5 p5){}
}
/***
*  Clase auxiliar para la interfaz del programa
*  
*
*
*/

public class UIManager
{
  ControlP5 cp5;
  Button loadImageButton;
  Button saveImageButton;
  Button applyFilterButton;
  
  ScrollableList listaFiltros;
  
  public UIManager(ControlP5 p5)
  {
    this.cp5 = p5;
    loadImageButton = new Button(p5, "Cargar Imagen");
    saveImageButton = new Button(p5, "Guardar Imagen");
    applyFilterButton = new Button(p5, "Aplicar");
    listaFiltros = new ScrollableList(p5, "Lista de filtros");
    
    //Boton para cargar imagen
    loadImageButton.setLabel("Cargar Imagen");
    loadImageButton.setPosition(10,10);
    loadImageButton.setSize(100, 30);
    loadImageButton.onRelease(event -> LoadImage());
    
    //Boton para guardar imagen
    saveImageButton.setLabel("Guardar Imagen");
    saveImageButton.setPosition(120,10);
    saveImageButton.setSize(100, 30);
    saveImageButton.onRelease(event -> SaveProcessed());
    
    //Boton para guardar imagen
    applyFilterButton.setLabel("Processar Filtro");
    applyFilterButton.setPosition(width - 500,10);
    applyFilterButton.setSize(100, 30);
    applyFilterButton.onRelease(event -> ApplyProcessing());
    
    setupFilterList();
  }
  
  private void setupFilterList()
  { 
    //UI
    listaFiltros.setOpen(false);
    listaFiltros.setPosition(width - 390, 10);
    listaFiltros.setBarHeight(30);
    listaFiltros.setWidth(100);
    listaFiltros.setItemHeight(25);
    listaFiltros.onLeave(event -> listaFiltros.close());
    listaFiltros.onChange(event -> updateUI());
  }
  /**
  *  Agrega una lista de filtros a la lista de la UI
  *
  *  @param filtros lista de filtros
  */
  public void AddFilterList(ArrayList<BaseFilter> filtros)
  {
    for(BaseFilter f : filtros)
    {
      listaFiltros.addItem(f.GetName(), listaFiltros);
    }
  }
  
  /**
  *  Regresa el indice del filtro seleccionado actualmente
  *
  *  @return indice del filtro seleccionado
  */
  public int GetCurrentSelectedFilter()
  {
    return (int)listaFiltros.getValue();
  }
  
}


  public void settings() { size(1200, 720); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "ProcesadorImagenes" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
